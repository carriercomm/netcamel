#!./luajit
--------------------------------------------------------------------------------
--  This file is part of NetCamel
--  Copyright (C) 2014 Lee Essen <lee.essen@nowonline.co.uk>
--
--  This program is free software: you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation, either version 3 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program.  If not, see <http://www.gnu.org/licenses/>.
------------------------------------------------------------------------------

local NTPD = "/usr/sbin/ntpd"
local NTPD_NAME = "ntpd"
local NTPD_ARGS = "-g"

--
-- NTP has a number of configuration options which we need to worry about,
-- also, if we are running the server as a server we need to trigger the
-- (input-standard-services) iptable macro
--
local function ntp_commit(changes)
	print("Hello From NTP")

	local cf = node_vars("service/ntp", CF_new)

	--
	-- Stop the daemon...
	--
	ntp_stop()

	--
	-- Check to see if we have a config at all!
	--
	if not next(cf) then
		print("No NTP config required, stopping daemon")
		return true
	end

	--
	-- Build the configuration file...
	--
	io.write(string.format("# <autogenerated ntp.conf file>\n"))
	io.write(string.format("#\n"))
	for server in each(cf.server) do
		io.write(string.format("# server %s iburst\n", server))
	end
	io.write(string.format("#\n"))
	io.write(string.format("# restrict default kod nomodify notrap nopeer noquery\n"))
	io.write(string.format("# restrict -6 default kod nomodify notrap nopeer noquery\n"))
	io.write(string.format("#\n"))
	io.write(string.format("# restrict 127.0.0.1\n"))
	io.write(string.format("# restrict -6 ::1\n"))
	io.write(string.format("#\n"))
	io.write(string.format("# interface ignore wildcard\n"))
	io.write(string.format("# interface listen 127.0.0.1\n"))
	for interface in each(cf["listen-on"]) do
		io.write(string.format("# interface listen %s\n", interface_name(interface)))
	end

	--
	-- If we are not enabled then exit before we start..
	--
	if not cf.enable then return true end

	--
	-- Start the daemon...
	--
	ntp_start()

	return true
end

--
-- Precommit will check to make sure the configuration makes sense, this
-- basically means that, if we are enabled, then we must have some servers
-- configured.
--
-- If we are providing a service then we must listen on one or more valid
-- interfaces.
--
local function ntp_precommit(changes)
	local cf = node_vars("service/ntp", CF_new)

	--
	-- if we are not enabled then we don't really care about anything
	--
	if not cf.enable then return true end

	--
	-- make sure we have at least one server configured
	--
	if #(cf.server or {}) < 1 then
		return false, "service/ntp/server must have at least one server configured"
	end

	--
	-- if we are not providing a service, then we are done, otherwise
	-- check the interfaces are ok
	--
	if not cf["provide-service"] then return true end
	if #(cf["listen-on"] or {}) < 1 then
		return false, "service/ntp/listen-on must list at least one interface for provide-service"
	end
	for interface in each(cf["listen-on"]) do
		if not node_exists(interface_path(interface), CF_new) then
			return false, string.format("service/ntp/listen-on interface not valid: %s", interface)
		end
	end
	return true
end

--
-- Provide the iptables rules for the iptables module, this assumes we
-- are using the CF_new configuration and just opens up ports using the
-- (input-allowed-services)
--
local function ntp_iptables_rules()
	local rules = {}

	print("AT NTP_IPTABLES_RULES")

	if CF_new["service/ntp/enable"] == true and CF_new["service/ntp/provide-service"] == true then
		for interface in each(CF_new["service/ntp/listen-on"] or {}) do
			interface = interface_name(interface)
			table.insert(rules, string.format("-i %s -p udp --dport 123 -j ACCEPT", interface))
		end
	end
	return rules
end

--
-- Functions to start and stop the ntp daemon
--
-- We use start-stop-daemon since the process forks and killing via a
-- pidfile doesn't kill the second process.
--
function ntp_start()
	print(string.format("start-stop-daemon -S -q -x %s -- %s", NTPD, NTPD_ARGS))
end
function ntp_stop()
	print(string.format("start-stop-daemon -K -q -n %s", NTPD_NAME))
end
function ntp_isrunning()
	print(string.format("start-stop-daemon -K -t -n %s", NTPD_NAME))
	-- TODO return value
end

--
-- Define the service so that we can stop, start and monitor the
-- daemon.
--
service.define("ntpd", {
    ["binary"] = "/home/essele/dev/netcamel/lua/testing/ntp",
    ["args"] = { "-g", "-p", "/var/run/ntpd.pid" },
    ["name"] = "pretend_ntp",
    ["pidfile"] = "/var/run/ntpd.pid",
    ["generate_pidfile"] = true,

    ["start"] = service.start_as_daemon,
    ["stop"] = service.kill_by_name,
})

--service.start("ntpd")
--service.stop("ntpd")

--
-- Main interface config definition
--
master["service"] = {}
master["service/ntp"] = { 
	["commit"] = ntp_commit,
	["precommit"] = ntp_precommit 
}

master["service/ntp/enable"] = { ["type"] = "bool" }
master["service/ntp/provide-service"] = { ["type"] = "bool" }
master["service/ntp/listen-on"] = { ["type"] = "interface", ["list"] = 1 }
master["service/ntp/server"] = { ["type"] = "OK", ["list"] = 1 }


function ntp_init()
	print("INIT_NTP")
	--
	-- If we change the settings we will need to adjust the iptables
	-- macro
	--
	add_trigger("service/ntp/enable", "iptables/*MACROS/@(input-allowed-services)")

	--
	-- Make sure we can contribute to the allowed services list...
	--
	iptables_add_macro_item("(input-allowed-services)", ntp_iptables_rules)
end

